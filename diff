1c1
< /* $Id: diff,v 1.1 1993-10-12 04:54:04 probe Exp $
---
> /* $Id: diff,v 1.1 1993-10-12 04:54:04 probe Exp $
20d19
< #include <fcntl.h>
37a37
> #include <sys/fcntl.h>
42c42
< char *version = "$Id: diff,v 1.1 1993-10-12 04:54:04 probe Exp $";
---
> char *version = "$Id: diff,v 1.1 1993-10-12 04:54:04 probe Exp $";
59d58
< #ifdef _AIX
61,67d59
<   { "proc" },
< #define MAX_PROC 1
<   { "max_proc" },
<   { ""}
< #else
< #ifdef SOLARIS
< #define PROC 0
72,79d63
< #else
< #define PROC 0
<   { "_proc" },
< #define NPROC 1
<   { "_nproc" },
<   { ""}
< #endif
< #endif
384,388c368
< #ifndef SOLARIS
<     struct proc p;
< #else
<     struct proc  *p;
< #endif
---
>     struct proc *p;
416,418d395
< #ifdef _AIX
<     nproc = (nl[MAX_PROC].n_value - nl[PROC].n_value) /
<       sizeof(nl[MAX_PROC].n_value);
420,448c397
<     lseek(kmem, nl[NPROC].n_value, L_SET);
<     read(kmem, &nproc, sizeof(nproc));
< #endif
< 
<     lseek(kmem, nl[PROC].n_value, L_SET);
<     read(kmem, &procp, sizeof(procp));
< #ifdef _AIX
<     lseek(kmem, ((int)procp & 0x7fffffff), L_SET);
< #else
<     lseek(kmem, procp, L_SET);
< #endif
< 
<     for (i = 0; i < nproc; i++) {
< #ifdef _AIX
<         readx(kmem, &p, sizeof(p), 1);
< 	read(kmem, &p, sizeof(p));
< #endif
< 	if (p.p_pid == 0) continue;
< #ifdef _AIX
< 	if (p.p_stat == SNONE) continue;
< #endif
< 	procs[i].pid = p.p_pid;
< 	procs[i].uid = p.p_uid;
<     }
<     close(kmem);
<     procs[i].pid = procs[i].uid = -1;
<     return(procs);
< #else /* SOLARIS */
<       kv = kvm_open(NULL,NULL,"/dev/swap",O_RDONLY,NULL);
---
>       kv = kvm_open(NULL,NULL,NULL,O_RDONLY,NULL);
452a402,403
> #endif
> 
455,471c406,422
<       i=0;
<       dirp = opendir("/proc");
<       for (j=0;j<2;j++)
<                       dp = readdir(dirp);
<       for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
<                       sscanf(dp->d_name,"%d",&pid);
<               p = kvm_getproc(kv,pid);
<               if ( p != NULL ) {
<                       if (p->p_epid == 0)
<                               continue;
<                       else {
<                               procs[i].pid = p->p_epid;
<                               procs[i].uid = p->p_uid;
<                               i++;
<                       }
<               }
<      }
---
> 	i=0;
> 	dirp = opendir("/proc");
> 	for (j=0;j<2;j++)
>        		dp = readdir(dirp);
> 	for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
>        		sscanf(dp->d_name,"%d",&pid);
> 		p = kvm_getproc(kv,pid);
> 		if ( p != NULL ) {
> 			if (p->p_epid == 0) 
> 				continue;  
> 			else {
> 				procs[i].pid = p->p_epid;
> 				procs[i].uid = p->p_uid;
> 				i++;
> 			}
> 		}
>     	}
475d425
< #endif
607d556
< 
610a560,565
> #ifdef SOLARIS
>     FILE *in, *in1, *out, *out1;
>     char username[10];
>     struct passwd *pw;
>     char buffer1[512];
> #else
611a567
> #endif
618a575
> #ifndef SOLARIS 
619a577
> #endif
636c594,611
< 
---
> #ifdef SOLARIS
>     out1 = fopen("/etc/shadow.new", "w");
>     if (out1 == NULL) {
> 	fprintf(stderr, "cleanup: unable to open /etc/shadow.new: %s\n",
> 		sys_errlist[errno]);
> 	fclose(in);
>         fclose(out);
> 	return(-1);
>     }
>     if (chmod("/etc/shadow.new", 0600)) {
> 	fprintf(stderr, "cleanup: unable to change mode of /etc/shadow.new: %s\n",
> 		sys_errlist[errno]);
> 	fclose(in);
> 	fclose(out);
>         fclose(out1);
> 	return(-1);
>     }
> #endif
655c630,635
< 
---
> #ifdef SOLARIS
>     in1 = fopen("/etc/shadow", "r");
>     if (in1 == NULL)
> 	fprintf(stderr, "cleanup: unable to open /etc/shadow: %s\n",
> 		sys_errlist[errno]);
> #endif
708a689,715
> #ifdef SOLARIS
>     /* now process /etc/shadow, avoiding duplicates */
>     while (in1 && fgets(buffer, sizeof(buffer), in1)) {
>        uid = -1;
>        strcpy(buffer1, buffer);
>        p = index(buffer1, ':');
>        if (p) {
>             strcpy(p, "\0");
>             strcpy(username, buffer1);
>             pw = getpwnam(username);
>             if (pw)
>                uid = pw-> pw_uid;
> 	  }
>        if (uid !=-1)
> 	       fputs(buffer, out1);
>     }
>     fclose(in1);
>     fclose(out1);
> #endif
> #ifdef SOLARIS
>     if (unlink("/etc/shadow"))
> 	fprintf(stderr, "cleanup: unable to remove /etc/shadow: %s\n",
> 		sys_errlist[errno]);
>     if (rename("/etc/shadow.new", "/etc/shadow"))
> 	fprintf(stderr, "cleanup: failed to rename /etc/passwd.new to /etc/passwd: %s\n",
> 		sys_errlist[errno]);
> #endif
836a844
> 
